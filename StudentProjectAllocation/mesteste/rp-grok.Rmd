---
title: | 
  | Analyse de deux algorithmes d'affectation optimale
  | ![](Images/logo_lamme.png){width=1in}  ![](Images/logo_UEVE.png){width=1.7in}
  | M2 Data Science Algorithmique 
author: "Vincent Runge"
date: "samedi 05 avril 2025"
header-includes:
  - \usepackage[french]{babel}
output:
  pdf_document:
    keep_tex: yes
    toc: true
    number_sections: true  
urlcolor: blue
---

\noindent\hrulefill

# Description du problème et objectif

Nous étudions dans ce document le problème d'affectation optimale d'étudiants à des projets. Ce problème consiste à assigner $n$ étudiants à $n$ projets de manière à minimiser une fonction de coût basée sur une matrice de préférences ou de "distances". C'est une version spécifique du problème d'affectation bipartite en optimisation combinatoire, également lié au problème du mariage stable.

Formellement, soit :
- Un ensemble d'étudiants $S = \{s_1, s_2, \ldots, s_n\}$,
- Un ensemble de projets $P = \{p_1, p_2, \ldots, p_n\}$,
- Une matrice de coût $C = \{c_{ij}\}$ où $c_{ij}$ représente la "distance" (ou le coût) entre l'étudiant $i$ et le projet $j$.

L'objectif est de trouver une permutation $\sigma$ qui minimise la somme suivante :
\[
\sum_{i=1}^n c_{i, \sigma(i)}
\]
où $\sigma(i)$ est le projet assigné à l'étudiant $i$.

Dans ce document, nous concentrons notre attention sur deux algorithmes d'affectation :
1) L'algorithme hongrois (*Hungarian Algorithm*), de complexité $O(n^3)$, qui garantit une solution optimale.
2) Un algorithme génétique, une méthode heuristique dont la complexité dépend de ses paramètres (nombre de générations, taille de la population), mais qui ne garantit pas l'optimum.

Nos objectifs sont :
a) Implémenter ces algorithmes en R et en C++ (via `hungarian_algorithm`, `genetic_algorithm_assignment`, `hungarian_algorithm_cpp`, `genetic_algorithm_cpp`) et évaluer leurs performances en temps d'exécution ;
b) Comparer la qualité des solutions (valeur de la fonction objectif) et confirmer les complexités théoriques par des simulations.

---

# Un premier exemple

```{r}
n <- 100
generate_matrix <- function(n) {
  matrix(apply(matrix(1:n, n, n, byrow = TRUE), 1, sample), 
         nrow = n, byrow = TRUE)
}
cost_matrix <- generate_matrix(n)
```


On teste les 4 algorithmes implémentés avec des noms explicites :

hungarian_algorithm
genetic_algorithm_assignment
hungarian_algorithm_cpp
genetic_algorithm_cpp

```{r}
cost_matrix[1:5, 1:5] # Aperçu de la matrice
hungarian_algorithm(cost_matrix)
genetic_algorithm_assignment(cost_matrix)
hungarian_algorithm_cpp(cost_matrix)
genetic_algorithm_cpp(cost_matrix)
```



#Comparaison R avec C++
On va comparer les deux types d'algorithmes en R et C++ pour quantifier leurs différences de performance.

Les fonctions suivantes mesurent le temps d'exécution et permettent l'utilisation avec microbenchmark :

```{r}
one.simu.time <- function(n, func = "hungarian_algorithm") {
  cost_matrix <- generate_matrix(n)
  if(func == "hungarian_algorithm") {t <- system.time(hungarian_algorithm(cost_matrix))[[1]]}
  if(func == "genetic_algorithm_assignment") {t <- system.time(genetic_algorithm_assignment(cost_matrix))[[1]]}
  if(func == "hungarian_algorithm_cpp") {t <- system.time(hungarian_algorithm_cpp(cost_matrix))[[1]]}
  if(func == "genetic_algorithm_cpp") {t <- system.time(genetic_algorithm_cpp(cost_matrix))[[1]]}
  return(t)
}

one.simu <- function(n, func = "hungarian_algorithm") {
  cost_matrix <- generate_matrix(n)
  if(func == "hungarian_algorithm") {hungarian_algorithm(cost_matrix)}
  if(func == "genetic_algorithm_assignment") {genetic_algorithm_assignment(cost_matrix)}
  if(func == "hungarian_algorithm_cpp") {hungarian_algorithm_cpp(cost_matrix)}
  if(func == "genetic_algorithm_cpp") {genetic_algorithm_cpp(cost_matrix)}
}
```


Un essai
Sur un exemple avec $n = 100$ :


```{r}
n <- 100
one.simu.time(n, func = "hungarian_algorithm")
one.simu.time(n, func = "genetic_algorithm_assignment")
one.simu.time(n, func = "hungarian_algorithm_cpp")
one.simu.time(n, func = "genetic_algorithm_cpp")
```


#Simulations avec répétitions
On reproduit ces comparaisons de manière plus robuste :

```{r}
nbSimus <- 10
n <- 100

time1 <- rep(0, nbSimus); time2 <- rep(0, nbSimus)
time3 <- rep(0, nbSimus); time4 <- rep(0, nbSimus)

for(i in 1:nbSimus) {time1[i] <- one.simu.time(n, func = "hungarian_algorithm")}
for(i in 1:nbSimus) {time2[i] <- one.simu.time(n, func = "hungarian_algorithm_cpp")}
for(i in 1:nbSimus) {time3[i] <- one.simu.time(n, func = "genetic_algorithm_assignment")}
for(i in 1:nbSimus) {time4[i] <- one.simu.time(n, func = "genetic_algorithm_cpp")}
```

Gain C++ versus R :

```{r}
mean(time1)/mean(time2) # Hungarian
mean(time3)/mean(time4) # Genetic
```

Gain hongrois versus génétique :

```{r}
mean(time1)/mean(time3) # R
mean(time2)/mean(time4) # C++
```


On recommence avec $n = 200$ pour le gain C++ sur l'algorithme hongrois :

```{r}
n <- 200
nbSimus <- 10
time1 <- rep(0, nbSimus); time2 <- rep(0, nbSimus)
for(i in 1:nbSimus) {time1[i] <- one.simu.time(n, func = "hungarian_algorithm")}
for(i in 1:nbSimus) {time2[i] <- one.simu.time(n, func = "hungarian_algorithm_cpp")}
median(time1)/median(time2)
```

#Conclusion :

- Le gain de performance entre C++ et R est significatif, notamment pour l'algorithme hongrois.
_ L'algorithme génétique peut être plus rapide mais sa qualité dépend des paramètres choisis.

#Simulations avec microbenchmark

```{r}
library(microbenchmark)
library(ggplot2)

benchmark_assignment <- function(n, times = 50) {
  microbenchmark(
    hungarian = one.simu(n, func = "hungarian_algorithm_cpp"),
    genetic = one.simu(n, func = "genetic_algorithm_cpp"),
    times = times
  )
}

n_values <- c(50, 100, 200)
results <- lapply(n_values, benchmark_assignment)
df_results <- do.call(rbind, Map(cbind, results, n = n_values))

ggplot(df_results, aes(x = expr, y = time / 1e6, fill = expr)) +
  geom_violin(alpha = 0.7) +
  facet_wrap(~n, scales = "free") +
  labs(title = "Assignment Algorithm Benchmark (C++)",
       x = "Algorithm", y = "Execution Time (ms)", fill = "Algorithm") +
  theme_minimal()
```


```{r}
library(dplyr)
df_results %>%
  group_by(n, expr) %>%
  summarise(
    median_time = median(time) / 1e6,
    mean_time = mean(time) / 1e6,
    .groups = "drop"
  )
```


#Évaluation de la complexité
On évalue la complexité en augmentant $n$ sur une échelle logarithmique :

```{r}
benchmark_assignment <- function(func_name, n_values, nbRep) {
  results <- sapply(n_values, function(n) {
    times <- replicate(nbRep, one.simu.time(n, func = func_name))
    c(mean_time = mean(times), sd_time = sd(times))
  })
  data.frame(n = n_values, mean_time = results["mean_time",], sd_time = results["sd_time",])
}

nbSimus <- 20; nbRep <- 10
vector_n <- exp(seq(log(50), log(500), length.out = nbSimus))
vector_n <- round(vector_n)

res_hungarian <- benchmark_assignment("hungarian_algorithm_cpp", vector_n, nbRep)
res_genetic <- benchmark_assignment("genetic_algorithm_cpp", vector_n, nbRep)

ggplot() +
  geom_line(data = res_hungarian, aes(x = n, y = mean_time, color = "Hungarian"), size = 1) +
  geom_errorbar(data = res_hungarian, aes(x = n, ymin = mean_time - sd_time, ymax = mean_time + sd_time, color = "Hungarian"), width = 0.1, alpha = 0.5) +
  geom_line(data = res_genetic, aes(x = n, y = mean_time, color = "Genetic"), size = 1) +
  geom_errorbar(data = res_genetic, aes(x = n, ymin = mean_time - sd_time, ymax = mean_time + sd_time, color = "Genetic"), width = 0.1, alpha = 0.5) +
  scale_x_log10() + scale_y_log10() +
  labs(title = "Assignment Algorithm Performance (Log-Log Scale)",
       x = "Matrix Size (log scale)", y = "Mean Running Time (log scale)", color = "Algorithm") +
  theme_minimal()
```


Vérification des exposants :

```{r}
# Check the data for problematic values
print("Hungarian mean_time summary:")
print(summary(res_hungarian$mean_time))
print("Genetic mean_time summary:")
print(summary(res_genetic$mean_time))

# Filter out rows with NA, NaN, Inf, or non-positive values
res_hungarian_clean <- res_hungarian[res_hungarian$mean_time > 0 & !is.na(res_hungarian$mean_time) & is.finite(log(res_hungarian$mean_time)), ]
res_genetic_clean <- res_genetic[res_genetic$mean_time > 0 & !is.na(res_genetic$mean_time) & is.finite(log(res_genetic$mean_time)), ]

# Check if there's enough data left after filtering
if(nrow(res_hungarian_clean) < 2 || nrow(res_genetic_clean) < 2) {
  stop("Not enough valid data points after filtering NA/NaN/Inf or non-positive values.")
}

# Fit the models with cleaned data
model_h <- lm(log(mean_time) ~ log(n), data = res_hungarian_clean)
cat("Hungarian exponent:", coef(model_h)[2], "\n")
model_g <- lm(log(mean_time) ~ log(n), data = res_genetic_clean)
cat("Genetic exponent:", coef(model_g)[2], "\n")
```


```{r}
model_h <- lm(log(res_hungarian$mean_time) ~ log(res_hungarian$n))
cat("Hungarian exponent:", coef(model_h)[2], "\n")
model_g <- lm(log(res_genetic$mean_time) ~ log(res_genetic$n))
cat("Genetic exponent:", coef(model_g)[2], "\n")
```

#Qualité de la solution
On compare la valeur de la fonction objectif pour $n = 100$ :

```{r}
n <- 100
cost_matrix <- generate_matrix(n)
sol_h <- hungarian_algorithm_cpp(cost_matrix)
sol_g <- genetic_algorithm_cpp(cost_matrix)
cost_h <- sum(cost_matrix[cbind(1:n, sol_h)])
cost_g <- sum(cost_matrix[cbind(1:n, sol_g)])
cat("Hungarian cost:", cost_h, "\nGenetic cost:", cost_g, "\n")
```

#Conclusion :

L'algorithme hongrois trouve toujours la solution optimale ($O(n^3)$).
L'algorithme génétique est plus rapide pour de grandes tailles mais peut s'éloigner de l'optimum.



